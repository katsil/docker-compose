> Prepare comprehensive documentation covering the deployment process, monitoring configuration, scaling strategies, and load testing. Include guidelines on how to build, run, and scale the system.

## 1. Деплой 
Деплоится приложение во время пуша в мастер ветку, за это отвечает раздел "only" в gitlab-ci файл. После билда имаджа автоматически происходит деплой на сервер. 

- 1.1 Необходимо указать переменные в gitlab для этого, а именно ssh ключ, ip сервера и пользователь, из под которого деплоится приложение. 
- 1.2 деплой происходит простым копированием gitlab репозитория, после этого запускается docker-compose файл. 

## 2. Мониторинг
Мониторинг также разворачивается вместе со всеми остальными компонентами. Изменение таргетов - `prometheus/prometheus.yml`, алертов - `prometheus/alert.rules.yml`. Сейчас мы мониторим 3 важных компонента для нашей системы:
- 2.1 базовый мониторинг nginx через встроенный stub_status
- 2.2 мониторинг времени ответов ручек flask приложения
- 2.3 cadvisor для HPA

Keep in mind, что мониторинг доступен по порту 10090 и проброшен на хост, то есть доступен извне без авторизации и фаервола в данном сетапе. 

Алертинг не настроен - прометус шлет алерты в alertmanager, однако далее он не роутит никуда сообщения, для этого нужно сделать template и указать корректного ресивера. 

## 3. Scale
Скейлинг _АВТОМАТИЧЕСКИ_ не деплоится. Так как это не стандартная конфигурация (в отличии от куба), необходимо разлить его самостоятельно (есть решения в виде интеграции с gitlab-ci, однако в данном документе они не описаны). 

Скейл работает следующим образом:
- скрипт опрашивает прометеус и собирает данные о CPU, Memory 
- в зависимости от указанных трешхолдов скрипт либо скейлит вверх на 1 реплику 
- либо скейлит вниз, если значения стали ниже пороговых значений. 
- скрипт не уведет деплоймент в 0 при достижении 1 рабочего контейнера 
- после того как скрипт увеличил или уменьшил количество реплик, мы автоматически делаем reload конфигурации nginx, чтобы новые контейнеры попали в балансировку

Разлить (сейчас в ручном режиме) скрипт автоскейла можно на любой сервер, а далее добавив его в cron - `crontab -e; * * * * python3 /path/to/hpa.py`, после этого он будет автоматически работать и запускаться раз в минуту. 

## 4. Load Testing
Есть 2 варианта тестирования, который зависит от необходимых данных разработчику:
- автоматическое тестирование при запуске docker-compose файла
- ручное тестирование с web ui

При первом варианте необходимо раскомментировать строку `entrypoint`:
```
   ->> comment out command: -f /mnt/locust/locustfile.py
   ->> uncomment #entrypoint: sh -c "sh /mnt/locust/run_locust.sh"
```
При ручном тестировании оставляем всё как есть. 

Автотесты запускаются после того как nginx контейнер стал доступен (для этого есть хелсчек по проверке бекенда), при ручном тестировании необходимо указать профиль нагрузки и куда отправлять запросы, в нашем случае: `http://nginx:80/`

## 5. Остальное
Запустить всё окружение можно из склонированного репозитория сразу же, выполнив `docker-compose up --build`, оно запустится не в демон режиме. Если необходимо протестировать конкретно flask, то используем `docker build -t flask-app python/Dockerfile` и затем 
`docker run -p 5000:5000 flask-app`. На всякий случай в контейнере мы можем менять порт, на котором он слушает запросы, с помощью переменной `PORT`. 

Если нам необходимо вручную отскейлить приложение, то используем команду `docker-compose up --scale flask-app={replicas} -d`, но затем не забываем перезапустить nginx (сделать reload - `docker-compose exec -T nginx nginx -s reload`)

## 6. Особенности
1. так как flask не обрабатывал ctrl+С при завершении работы докер-компоуза, добавил обработчик этого статус кода
2. добавил отдельную ручку по мониторингу фласка, в связи с этим появилась библиотека по прометеусу в коде приложения
3. весь мониторинг стейтлесс, при перезапуске данные удаляются 
